# ================================================
# pages/Spinning_Production.py
# ================================================
import os, io, json, re, datetime as dt
import pandas as pd
import streamlit as st
from pymongo import MongoClient, ReturnDocument
from dotenv import load_dotenv
import google.generativeai as genai

# ------------------ CONFIG ------------------
st.set_page_config(page_title="Spinning Production OCR", layout="wide")
load_dotenv()

MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017")
DB_NAME = os.getenv("DB_NAME", "mill_registers")
COLL_NAME = "spinning_production_entries"
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY", "")

mongo_client = MongoClient(MONGO_URI)
db = mongo_client[DB_NAME]
coll = db[COLL_NAME]

if GOOGLE_API_KEY:
    genai.configure(api_key=GOOGLE_API_KEY)

# ------------------ CONSTANTS ------------------
ROW_COLUMNS = [
    "Sl_No", "Quality",
    "Frame_A", "Frame_B", "Frame_C",
    "Production_A", "Production_B", "Production_C",
]

NUMERIC_COLS = ["Frame_A", "Frame_B", "Frame_C",
                "Production_A", "Production_B", "Production_C"]

# ------------------ HELPERS ------------------
def json_safe_load(s: str) -> dict:
    try:
        return json.loads(s)
    except:
        m = re.search(r"\{.*\}", str(s), flags=re.S)
        if m:
            try:
                return json.loads(m.group(0))
            except:
                return {"header": {}, "rows": []}
    return {"header": {}, "rows": []}

def to_int(x):
    try:
        if x in [None, "", "null", "-", "‚Äî"]:
            return None
        return int(str(x).strip())
    except:
        return None

# ------------------ NORMALIZATION ------------------
def normalize_rows(rows: list) -> pd.DataFrame:
    """Fix repeating values, remove extracted totals, and keep OCR manual total."""
    norm = []

    prev_A = prev_B = prev_C = None
    prev_PA = prev_PB = prev_PC = None

    def repeat(val, prev):
        if str(val).strip() in ["", ",,", None]:
            return prev
        return val

    for r in rows or []:
        # repeating logic
        A_raw = repeat(r.get("Frame_A"), prev_A)
        B_raw = repeat(r.get("Frame_B"), prev_B)
        C_raw = repeat(r.get("Frame_C"), prev_C)

        PA_raw = repeat(r.get("Production_A"), prev_PA)
        PB_raw = repeat(r.get("Production_B"), prev_PB)
        PC_raw = repeat(r.get("Production_C"), prev_PC)

        prev_A, prev_B, prev_C = A_raw, B_raw, C_raw
        prev_PA, prev_PB, prev_PC = PA_raw, PB_raw, PC_raw

        row = {
            "Sl_No": to_int(r.get("Sl_No")),
            "Quality": (r.get("Quality") or "").strip(),

            "Frame_A": to_int(A_raw),
            "Frame_B": to_int(B_raw),
            "Frame_C": to_int(C_raw),

            "Production_A": to_int(PA_raw),
            "Production_B": to_int(PB_raw),
            "Production_C": to_int(PC_raw),
        }
        norm.append(row)

    df = pd.DataFrame(norm, columns=ROW_COLUMNS)

    # Remove any total row wrongly generated by OCR
    df = df[df["Sl_No"].astype(str).str.lower() != "total"]

    return df

# ------------------ GEMINI OCR ------------------
def call_gemini_for_spinning(image_bytes: bytes, mime_type: str) -> dict:
    prompt = """
Extract strictly in the JSON format:

{
  "header": {"Date": "...", "Supervisor_Signature": "..."},
  "rows": [
    {
      "Sl_No": int,
      "Quality": str,
      "Frame_A": int,
      "Frame_B": int,
      "Frame_C": int,
      "Production_A": int,
      "Production_B": int,
      "Production_C": int
    }
  ]
}

Rules:
- ,, means value same as previous row.
- Do NOT calculate totals; return the manual total row from the sheet as last row.
"""
    try:
        model = genai.GenerativeModel("gemini-2.5-flash")
        cfg = {"response_mime_type": "application/json"}
        resp = model.generate_content(
            [prompt, {"mime_type": mime_type, "data": image_bytes}],
            generation_config=cfg,
        )
        return json_safe_load(resp.text)
    except:
        return {"header": {}, "rows": []}

# ------------------ MONGO UPSERT ------------------
def upsert_mongo(header: dict, df: pd.DataFrame, img_name: str):
    df_to_store = df.copy()

    doc = {
        "register_type": "Spinning Production",
        "header": header,
        "timestamp": dt.datetime.utcnow(),
        "original_image_name": img_name,
        "extracted_data": df_to_store.to_dict(orient="records"),
        "validated": False,
    }

    key = {"original_image_name": img_name}

    return coll.find_one_and_update(
        key, {"$set": doc}, upsert=True, return_document=ReturnDocument.AFTER
    )

# ------------------ UI ------------------
st.title("üßµ Spinning Production OCR")

with st.sidebar:
    cam = st.camera_input("üì∏ Capture Image")
    up = st.file_uploader("üìÅ Upload Image", type=["png", "jpg", "jpeg"])

img_bytes = img_name = mime = None
if cam:
    img_bytes = cam.getvalue()
    img_name = f"cam_{dt.datetime.utcnow().isoformat()}.jpg"
    mime = "image/jpeg"
elif up:
    img_bytes = up.getvalue()
    img_name = up.name
    mime = up.type

if not img_bytes:
    st.stop()

st.image(img_bytes, caption="Input Image", use_column_width=True)

data = call_gemini_for_spinning(img_bytes, mime)
header = data.get("header", {})
rows = data.get("rows", [])

df = normalize_rows(rows)

# ------------------ DISPLAY ------------------
edited = st.data_editor(df, use_container_width=True, num_rows="dynamic")

# ------------------ TOTALS ------------------
A_total = edited["Frame_A"].sum()
B_total = edited["Frame_B"].sum()
C_total = edited["Frame_C"].sum()

PA_total = edited["Production_A"].sum()
PB_total = edited["Production_B"].sum()
PC_total = edited["Production_C"].sum()

grand_total = PA_total + PB_total + PC_total
frame_total = A_total + B_total + C_total

FS_ratio = round(grand_total / frame_total, 2) if frame_total else None

st.subheader("üìå Summary (Auto-Calculated)")
st.write(f"**Total Frames (A + B + C):** {frame_total}")
st.write(f"**Total Production (A + B + C):** {grand_total}")
st.write(f"**F/S Ratio:** {FS_ratio}")

# ------------------ HEADER ------------------
c1, c2 = st.columns(2)
date_val = c1.text_input("Date", value=header.get("Date") or "")
sup_val = c2.text_input("Supervisor Signature", value=header.get("Supervisor_Signature") or "")
header_edit = {"Date": date_val, "Supervisor_Signature": sup_val}

# ------------------ SAVE ------------------
if st.button("üíæ Save to MongoDB"):
    saved = upsert_mongo(header_edit, edited, img_name)
    st.success("Saved!")
    st.json({"_id": str(saved.get("_id"))})

# ------------------ EXPORT ------------------
st.download_button("‚¨á CSV", edited.to_csv(index=False), "spinning.csv")
st.download_button("‚¨á JSON", edited.to_json(orient="records", indent=2), "spinning.json")
